#!/usr/bin/env bash -i

# MARK: utilities

with-echo() {
    echo -e "\033[35m@echo\033[0m $@" && $@
    ret=$?
    if [ $ret -ne 0 ]; then
        echo -e "\033[35m@echo run has failed\033[0m" && exit $ret
    fi
}

shortlist() {
    typeset -f | awk '/ \(\) $/ { print $1 } ' | grep -v -e shortlist -e with-echo -e install_completion
}

install-completion() {
    mkdir -p "$HOME/.bash_completion.d"
    sed "s;{{PROJECT_DIR}};$(pwd -P);g" shell/tde-commands.completion.template.sh >"$HOME/.bash_completion.d/tde_commands.sh"
    source "$HOME/.bash_completion.d/tde_commands.sh"
}

PROGRAM_NAMES="$(find cmd -name 'main.go' | cut -d '/' -f 2 | sort | uniq)"

version() {
    echo "$(date -u +%y%m%d-%H%M%S)-$(git rev-parse HEAD | cut -b 1-8)"
}

# MARK: Compile

build() {
    PROGRAM_NAME="$1" && shift
    VERSION="$(version)"
    mkdir -p "build/$VERSION"
    with-echo env GOOS=darwin GOARCH=amd64 go build -o "build/$VERSION/$PROGRAM_NAME-darwin-amd64" ./cmd/$PROGRAM_NAME
    with-echo env GOOS=linux GOARCH=amd64 go build -o "build/$VERSION/$PROGRAM_NAME-linux-amd64" ./cmd/$PROGRAM_NAME
}

build-all() {
    for PROGRAM_NAME in $PROGRAM_NAMES; do with-echo build "$PROGRAM_NAME"; done
}

last-build-any() {
    find build -type d -maxdepth 2 -mindepth 1 | sort | tail -n 1 | cut -f 2 -d '/'
}

last-build() {
    PROGRAM_NAME="$1" && shift
    find build -name "*$PROGRAM_NAME*" | sort | tail -n 1 | cut -f 2 -d '/'
}

# MARK: Run

run() {
    PROGRAM_NAME="$1" && shift
    with-echo go run "tde/cmd/$PROGRAM_NAME" --config="platform/local/config.yml" "$@"
}

run-last-build() {
    PROGRAM_NAME="$1" && shift
    PROGRAM_LAST_BUILD="$(last-build $PROGRAM_NAME)"
    with-echo "./build/$PROGRAM_LAST_BUILD/$PROGRAM_NAME-darwin-amd64" --config="platform/local/config.yml" "$@"
}

build-and-run() {
    PROGRAM_NAME="$1" && shift
    build "$PROGRAM_NAME"
    run "$PROGRAM_NAME" "$@"
}

# MARK: Re-Deployment (only binaries for one server kind)

redeploy() {
    PROGRAM_NAME="$1" && shift
    (cd platform/stage/2-deployment && with-echo ansible-playbook --forks="20" --limit="$PROGRAM_NAME" --tags="redeploy" playbook.yml)
}

build-redeploy() {
    PROGRAM_NAME="$1" && shift
    build "$PROGRAM_NAME"
    redeploy "$PROGRAM_NAME"
}

# MARK: API

print-endpoints() {
    cat api.http | grep HTTP/1.1 |
        cut -d ' ' -f 1-2 | awk '{ print $2, $1 }' |
        sort | awk '{ print $2, "\t", $1 }' |
        sed -E 's/(.*){{api}}(.*)/\1 \2/'
}

update-stage() {
    API_GATEWAY_IP_ADDRESS="$(cat platform/stage/2-deployment/service_discovery.json | jq -r '.["api-gateway"].digitalocean[0].ipv4_address')"
    CUSTOMS_IP_ADDRESS="$(cat platform/stage/2-deployment/service_discovery.json | jq -r '.["customs"].digitalocean[0].ipv4_address')"
    gsed --in-place "s;^@api.*;@api = http://${API_GATEWAY_IP_ADDRESS}:8080/api/v1.0.0;" api.http
    gsed --in-place "s;^# @api.*;# @api = http://127.0.0.1:8087/api/v1.0.0;" api.http
}

ip-of() {
    PROGRAM_NAME="$1"
    cat platform/stage/2-deployment/service_discovery.json | jq -r ".[\"$PROGRAM_NAME\"].digitalocean[0].ipv4_address"
}

# MARK: main

SUBCOMMAND="$1" && shift && "$SUBCOMMAND" "$@"
